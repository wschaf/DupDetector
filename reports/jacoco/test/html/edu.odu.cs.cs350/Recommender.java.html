<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Recommender.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DupDetector</a> &gt; <a href="index.source.html" class="el_package">edu.odu.cs.cs350</a> &gt; <span class="el_source">Recommender.java</span></div><h1>Recommender.java</h1><pre class="source lang-java linenums">package edu.odu.cs.cs350;

import edu.odu.cs.cs350.Interfaces.*;

import java.util.*;
import java.math.BigDecimal;

/**
 * Taking as input a list of tokens which represents a string of
 * tokens taken from all files that the Input processed. It will
 * process these tokens, and produce a list of recommended
 * refactorings, ordered from greatest to least opportunity value.
 * Additionally, after finding a refactoring recommendation, but
 * before adding the recommendation to the list of recommendations,
 * it will compute the opportunity value of that recommendation.
 * @see RecommenderInterface
 * @see TestRecomender
 */
public class Recommender implements RecommenderInterface {

    private List&lt;TokenInterface&gt; tokens;
    private List&lt;RefactoringInterface&gt; refactorings;
    private int minRefactoringSize;
    private int maxRefactoringSize;

    /**
     * Default constructor.
     * tokens and refactorings are set to empty lists;
     * minRefactoringSize and maxRefactoringSize are set to 0.
     */
<span class="fc" id="L31">    Recommender() {</span>
<span class="fc" id="L32">        this.setTokens(new ArrayList&lt;TokenInterface&gt;());</span>
<span class="fc" id="L33">        this.setRefactorings(new ArrayList&lt;RefactoringInterface&gt;());</span>
<span class="fc" id="L34">        this.setMinRefactoringSize(0);</span>
<span class="fc" id="L35">        this.setMaxRefactoringSize(0);</span>
<span class="fc" id="L36">    }</span>

    /**
     * Parameter constructor. with a list of tokens provided.
     * tokens is set to inputTokens, recommend runs to set
     * the Refactorings list, 
     * @param inputTokens a list of tokens produced from lexical
     * analysis of all the files provided as input.
     */
<span class="fc" id="L45">    Recommender(List&lt;? extends TokenInterface&gt; inputTokens) {</span>
<span class="fc" id="L46">        this.setTokens(inputTokens);</span>
<span class="fc" id="L47">        this.refactorings = new ArrayList&lt;RefactoringInterface&gt;();</span>
<span class="fc" id="L48">        this.setMinRefactoringSize();</span>
<span class="fc" id="L49">        this.setMaxRefactoringSize();</span>
<span class="fc" id="L50">    }</span>

    /**
     * Parameter constructor, with tokens and min and max size of refactorings parameters.
     * @param inputTokensa list of tokens produced from lexical
     * analysis of all the files provided as input.
     * @param min the least number of tokens that a refactoring candidate can have.
     * @param max the highest number of tokens that a refactoring candidate can have.
     */
<span class="fc" id="L59">    Recommender(List&lt;? extends TokenInterface&gt; inputTokens, int min, int max) {</span>
<span class="fc" id="L60">        this.setTokens(inputTokens);</span>
<span class="fc" id="L61">        this.setMinRefactoringSize(min);</span>
<span class="fc" id="L62">        this.setMaxRefactoringSize(max);</span>
<span class="fc" id="L63">        this.recommend();</span>
<span class="fc" id="L64">    }</span>

    /**
     * @return the list of tokens from which the recommendations
     * are generated.
     */
    @Override
    public List&lt;? extends TokenInterface&gt; getTokens() {
<span class="fc" id="L72">        return this.tokens;</span>
    }

    /**
     * Sets the list of tokens from which recommendations are
     * generated to the input list parameter.
     * @param input a list of token objects.
     */
    @Override
    public void setTokens(List&lt;? extends TokenInterface&gt; input) {
<span class="pc bpc" id="L82" title="1 of 4 branches missed.">        if (input == null || input.size() == 0) {</span>
<span class="fc" id="L83">            tokens = new ArrayList&lt;TokenInterface&gt;();</span>
<span class="fc" id="L84">            return;</span>
        }
<span class="fc" id="L86">        tokens = new ArrayList&lt;TokenInterface&gt;();</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        for (TokenInterface t : input) tokens.add(t);</span>
<span class="fc" id="L88">    }</span>

    /**
     * If no refactorings have been created, create them.
     * @return a complete list of all refactoring recommendations.
     */
    @Override
    public List&lt;? extends RefactoringInterface&gt; getRefactorings() {
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (this.refactorings.size() != 0) return this.refactorings;</span>
<span class="pc bpc" id="L97" title="1 of 4 branches missed.">        if (this.tokens == null || this.tokens.size() == 0) return new ArrayList&lt;RefactoringInterface&gt;();</span>
<span class="pc bpc" id="L98" title="2 of 4 branches missed.">        if (this.refactorings == null || this.refactorings.isEmpty()) this.recommend();</span>
<span class="fc" id="L99">        return this.refactorings;</span>
    }

    /**
     * Sets recommender's list of refactorings to a pre-existing
     * refactoring list.
     * @param input a list of Refactoring recommendations.
     */
    @Override
    public void setRefactorings(List&lt;? extends RefactoringInterface&gt; input) {
<span class="pc bpc" id="L109" title="1 of 4 branches missed.">        if (input.isEmpty() || input == null) {</span>
<span class="fc" id="L110">            refactorings = new ArrayList&lt;RefactoringInterface&gt;();</span>
        }
        else {
<span class="fc" id="L113">            refactorings = new ArrayList&lt;RefactoringInterface&gt;();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (RefactoringInterface r : input) refactorings.add(r);</span>
        }
<span class="fc" id="L116">    }</span>

    /**
     * Recommended refactorings should be greater than
     * minRefactoringSize but less than maxRefactoringSize,
     * inclusive.
     * @return the minimum number of tokens that can make up a
     * refactoring.
     */
    @Override
    public int getMinRefactoringSize() {
<span class="fc" id="L127">        return this.minRefactoringSize;</span>
    }

    /**
     * Recommended refactorings should be greater than
     * minRefactoringSize but less than maxRefactoringSize,
     * inclusive.
     * @param input the minimum number of tokens that can make up a
     * refactoring.
     */
    @Override
    public void setMinRefactoringSize(int input) {
<span class="fc" id="L139">        this.minRefactoringSize = input;</span>
<span class="fc" id="L140">    }</span>

    /**
     * Recommended refactorings should be greater than
     * minRefactoringSize but less than maxRefactoringSize,
     * inclusive. If no input was provided, sets the min to
     * 0 if Recommender's list of tokens is empty, or to 3%
     * of the size of the token list.
     */
    @Override
    public void setMinRefactoringSize() {
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">        if (this.getTokens().isEmpty() || this.getTokens() == null) {</span>
<span class="fc" id="L152">            this.minRefactoringSize = 0;</span>
<span class="fc" id="L153">            return;</span>
        }
        else {
<span class="fc" id="L156">            BigDecimal size = new BigDecimal(this.getTokens().size());</span>
<span class="fc" id="L157">            BigDecimal result = size.multiply(new BigDecimal(&quot;0.03&quot;));</span>
<span class="fc" id="L158">            this.minRefactoringSize = result.intValue();</span>
<span class="fc" id="L159">            return;</span>
        }
    }

    /**
     * Recommended refactorings should be greater than
     * minRefactoringSize but less than maxRefactoringSize,
     * inclusive.
     * @return the maximum number of tokens that can make up a
     * refactoring.
     */
    @Override
    public int getMaxRefactoringSize() {
<span class="fc" id="L172">        return this.maxRefactoringSize;</span>
    }

    /**
     * Recommended refactorings should be greater than
     * minRefactoringSize but less than maxRefactoringSize,
     * inclusive.
     * @param input the maximum number of tokens that can make up a
     * refactoring.
     */
    @Override
    public void setMaxRefactoringSize(int input) {
<span class="fc" id="L184">        this.maxRefactoringSize = input;</span>
<span class="fc" id="L185">    }</span>

    /**
     * Recommended refactorings should be greater than
     * minRefactoringSize but less than maxRefactoringSize,
     * inclusive. If no input was provided, sets the max to
     * 0 if Recommender's list of tokens is empty, or to 75%
     * of the size of the token list.
     */
    @Override
    public void setMaxRefactoringSize() {
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">        if (this.getTokens().isEmpty() || this.getTokens() == null) {</span>
<span class="fc" id="L197">            this.maxRefactoringSize = 0;</span>
<span class="fc" id="L198">            return;</span>
        }
        else {
<span class="fc" id="L201">            BigDecimal size = new BigDecimal(this.getTokens().size());</span>
<span class="fc" id="L202">            BigDecimal result = size.multiply(new BigDecimal(&quot;0.70&quot;));</span>
<span class="fc" id="L203">            this.maxRefactoringSize = result.intValue();</span>
<span class="fc" id="L204">            return;</span>
        }
    }

    /**
     * Computes the opportunity value for refactoring for candidate,
     * based on its size and number of reoccurrences in the list of
     * tokens that was given to Recommender.
     * @param candidate a list of tokens that is a candidate for
     * refactorization.
     * @param amountOfDuplicates the number of times the candidate
     * reoccurs in tokens.
     * @param 
     * @return an integer between 0 and 100, inclusive, representing
     * the amount of value a refactoring candidate has.
     */
    private int computeOpportunityValue(List&lt;TokenInterface&gt; candidate, int amountOfDuplicates, int amountOfSublists) {
        /**
         * Formula for calculating opportunity value:
         * A = candidate.size() / tokens.size()
         * B = amountOfDuplicates / sublists.size()
         * value = ( A + B ) * 100
         */

        /*BigDecimal A = new BigDecimal(candidate.size());
        A.divide(new BigDecimal(tokens.size()));

        BigDecimal B = new BigDecimal(amountOfDuplicates);
        B.divide(new BigDecimal(amountOfSublists));

        BigDecimal result = A.add(B);
        result.multiply(new BigDecimal(100));*/
        //return result.intValue();
<span class="fc" id="L237">        return 5;</span>
    }

    /**
     * Using the list of tokens, finds all suggested refactorings of
     * those tokens, calculates the opportunity value for each
     * candidate, and then produces a list of suggested
     * refactorings.
     */
    private void recommend() {
<span class="fc" id="L247">        this.refactorings = new ArrayList&lt;RefactoringInterface&gt;();</span>
<span class="pc bpc" id="L248" title="1 of 6 branches missed.">        if (this.tokens == null || this.tokens.size() &lt;= 1 || this.getMaxRefactoringSize() &lt;= 3) return;</span>

        //  sublists stores each of the created candidate list of tokens.
<span class="fc" id="L251">        List&lt;List&lt;TokenInterface&gt;&gt; sublists = new ArrayList&lt;List&lt;TokenInterface&gt;&gt;();</span>

        //  Create lists with varying sizes between minRefactoringSize up to and including maxRefactoringSize.
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (int i = this.getMinRefactoringSize(); i &lt;= this.getMaxRefactoringSize(); i++) {</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            for (int j = 0; j &lt; this.getTokens().size(); j++) {</span>
                try {
<span class="fc" id="L257">                    List&lt;TokenInterface&gt; l = tokens.subList(j, ( j + i));</span>
                    //  Only add full statements, must end in a ';' or '}'
<span class="pc bpc" id="L259" title="1 of 4 branches missed.">                    if (l.get(l.size() - 1).getTokenType() == TokenType.SEMI_COLON || l.get(l.size() - 1).getTokenType() == TokenType.RIGHT_BRACE) {</span>
<span class="fc" id="L260">                        sublists.add(l);</span>
                    }
<span class="fc" id="L262">                } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L263">                    continue;</span>
<span class="fc" id="L264">                }</span>
            }
        }

<span class="pc bpc" id="L268" title="2 of 4 branches missed.">        if (sublists == null || sublists.size() == 0) return;</span>

        //  Determine whether each sublist is a recommended refactoring.
<span class="fc bfc" id="L271" title="All 2 branches covered.">        for (var list : sublists) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (list.size() &lt;= 2) continue;</span>
<span class="fc" id="L273">            int occurrences = countOccurrences(list, sublists);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (occurrences &gt; 1) {</span>
<span class="fc" id="L275">                int opportunityValue = computeOpportunityValue(list, occurrences - 1, sublists.size());</span>
<span class="fc" id="L276">                Refactoring r = new Refactoring(list, opportunityValue);</span>
<span class="fc" id="L277">                this.refactorings.add(r);</span>
            }
<span class="fc" id="L279">        }</span>
<span class="fc" id="L280">    }</span>

    /**
     * Counts the number of times candidate reoccurs in sublists.
     * @param candidate the list of tokens representing a candidate for refactorization.
     * @param sublists the list of all sublists of tokens.
     * @return the number of times candidate reoccurs in sublists (counting itself).
     */
    private int countOccurrences(List&lt;TokenInterface&gt; candidate, List&lt;List&lt;TokenInterface&gt;&gt; sublists) {
<span class="fc" id="L289">        int result = 0;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (List&lt;TokenInterface&gt; list : sublists) {</span>
<span class="fc" id="L291">            boolean equalTo = true;</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (list.size() == candidate.size()) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">                for (int i = 0; i &lt; candidate.size(); i++) {</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                    if (candidate.get(i).getTokenType() != list.get(i).getTokenType()) equalTo = false;</span>
                }
            }
            else {
<span class="fc" id="L298">                equalTo = false;</span>
            }
<span class="fc bfc" id="L300" title="All 2 branches covered.">            if (equalTo == true) result++;</span>
<span class="fc" id="L301">        }</span>
<span class="fc" id="L302">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>